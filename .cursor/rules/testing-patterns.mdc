---
description: Vitest test structure, naming conventions, and testing patterns
globs: ["**/*.test.ts", "**/*.spec.ts"]
---

# Testing Patterns

## Overview
The project uses Vitest for testing. Tests are co-located with source files using `.test.ts` suffix. Focus on unit testing utility functions and service logic.

## Test File Organization

### File Naming
- ✅ **ALWAYS** use `.test.ts` suffix for test files
- ✅ **ALWAYS** co-locate test files with source files
- ✅ **ALWAYS** name test files: `{moduleName}.test.ts`

```
src/
├── utils/
│   ├── scoring.ts
│   └── scoring.test.ts
├── services/
│   ├── spacedRepetition.ts
│   └── spacedRepetition.test.ts
```

### Test Structure
- ✅ **ALWAYS** use `describe` blocks to group related tests
- ✅ **ALWAYS** use descriptive test names: `'should return true for correct single answer'`
- ✅ **ALWAYS** use `it` or `test` for individual test cases

```typescript
import { describe, it, expect } from 'vitest';
import { checkAnswerCorrect } from './scoring.js';

describe('checkAnswerCorrect', () => {
  describe('single choice questions', () => {
    it('should return true for correct single answer', () => {
      expect(checkAnswerCorrect([2], [2])).toBe(true);
    });

    it('should return false for incorrect single answer', () => {
      expect(checkAnswerCorrect([1], [2])).toBe(false);
    });
  });
});
```

## Test Patterns

### Unit Testing Utilities
- ✅ **ALWAYS** test pure functions with various inputs
- ✅ **ALWAYS** test edge cases: empty arrays, null values, boundary conditions
- ✅ **ALWAYS** group tests by function/feature

```typescript
describe('calculateExamScore', () => {
  it('should return 100 for all correct', () => {
    expect(calculateExamScore(50, 50)).toBe(100);
  });

  it('should return 0 for all incorrect', () => {
    expect(calculateExamScore(0, 50)).toBe(0);
  });

  it('should calculate percentage correctly', () => {
    expect(calculateExamScore(35, 50)).toBe(70);
    expect(calculateExamScore(25, 50)).toBe(50);
  });

  it('should handle edge cases', () => {
    expect(calculateExamScore(0, 0)).toBe(0);
    expect(calculateExamScore(1, 3)).toBeCloseTo(33.333, 2);
  });
});
```

### Testing Edge Cases
- ✅ **ALWAYS** test boundary conditions
- ✅ **ALWAYS** test empty/null/undefined inputs
- ✅ **ALWAYS** test invalid inputs when appropriate

```typescript
describe('edge cases', () => {
  it('should handle empty arrays (no answer selected)', () => {
    expect(checkAnswerCorrect([], [])).toBe(true);
  });

  it('should return false when no answer selected but answer expected', () => {
    expect(checkAnswerCorrect([], [1])).toBe(false);
  });

  it('should handle answer index 0', () => {
    expect(checkAnswerCorrect([0], [0])).toBe(true);
  });

  it('should handle large indices', () => {
    expect(checkAnswerCorrect([99], [99])).toBe(true);
  });
});
```

### Testing Multiple Scenarios
- ✅ **ALWAYS** test both positive and negative cases
- ✅ **ALWAYS** test different input combinations
- ✅ **ALWAYS** use descriptive test names that explain the scenario

```typescript
describe('multiple choice questions', () => {
  it('should return true for all correct answers selected', () => {
    expect(checkAnswerCorrect([0, 2], [0, 2])).toBe(true);
  });

  it('should return true regardless of order', () => {
    expect(checkAnswerCorrect([2, 0], [0, 2])).toBe(true);
  });

  it('should return false for partial selection', () => {
    expect(checkAnswerCorrect([0], [0, 2])).toBe(false);
  });

  it('should return false for over-selection', () => {
    expect(checkAnswerCorrect([0, 1, 2], [0, 2])).toBe(false);
  });
});
```

## Assertions

### Using Expect
- ✅ **ALWAYS** use `expect().toBe()` for exact equality
- ✅ **ALWAYS** use `expect().toBeCloseTo()` for floating point comparisons
- ✅ **ALWAYS** use `expect().toEqual()` for object/array comparisons

```typescript
// ✅ CORRECT - Exact match
expect(calculateExamScore(50, 50)).toBe(100);

// ✅ CORRECT - Floating point
expect(calculateExamScore(1, 3)).toBeCloseTo(33.333, 2);

// ✅ CORRECT - Object comparison
expect(result).toEqual({
  domainId: 1,
  correct: 1,
  total: 2,
  percentage: 50,
});
```

### Testing Arrays and Objects
- ✅ **ALWAYS** test array length when relevant
- ✅ **ALWAYS** use `toHaveLength()` for array length assertions
- ✅ **ALWAYS** use `find()` to locate specific items in arrays

```typescript
const result = calculateDomainPerformance(responses);
expect(result).toHaveLength(2);

const domain1 = result.find((d) => d.domainId === 1);
expect(domain1).toEqual({
  domainId: 1,
  correct: 1,
  total: 2,
  percentage: 50,
});
```

## Test Data

### Test Fixtures
- ✅ **ALWAYS** create minimal test data needed for each test
- ✅ **ALWAYS** use realistic but simple test data
- ✅ **ALWAYS** avoid sharing mutable state between tests

```typescript
describe('calculateAccuracy', () => {
  it('should return 100 for all correct', () => {
    const responses = [
      { isCorrect: true },
      { isCorrect: true },
      { isCorrect: true },
    ];
    expect(calculateAccuracy(responses)).toBe(100);
  });

  it('should ignore null (unanswered) responses', () => {
    const responses = [
      { isCorrect: true },
      { isCorrect: null },
      { isCorrect: true },
      { isCorrect: null },
    ];
    expect(calculateAccuracy(responses)).toBe(100);
  });
});
```

## Running Tests

### Test Commands
- ✅ **ALWAYS** use `npm run test` for one-time test run
- ✅ **ALWAYS** use `npm run test:watch` for development
- ✅ **ALWAYS** use `npm run test:coverage` for coverage reports

```bash
npm run test              # Run all tests once
npm run test:watch        # Watch mode for development
npm run test:coverage     # Generate coverage report
```

## Test Organization

### Grouping Related Tests
- ✅ **ALWAYS** use nested `describe` blocks for logical grouping
- ✅ **ALWAYS** group tests by function, then by scenario type

```typescript
describe('checkAnswerCorrect', () => {
  describe('single choice questions', () => {
    // Single choice tests
  });

  describe('multiple choice questions', () => {
    // Multiple choice tests
  });

  describe('edge cases', () => {
    // Edge case tests
  });
});
```

## Anti-Patterns

- ❌ **NEVER** test implementation details - test behavior
- ❌ **NEVER** share mutable state between tests
- ❌ **NEVER** skip edge cases - test boundary conditions
- ❌ **NEVER** use vague test names - be descriptive
- ❌ **NEVER** test multiple things in one test case
- ❌ **NEVER** forget to test error cases
- ❌ **NEVER** use `any` type in test data

## Related Patterns
- See `server-patterns.mdc` for service layer patterns to test
- See `validation-patterns.mdc` for schema validation patterns
